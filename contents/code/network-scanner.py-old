# File: contents/code/network-scanner.py
# X-Seti Jan 2019, 2025 - network-scanner

#!/usr/bin/env python3

import sys
import subprocess
import socket
import json
import time
import argparse
from concurrent.futures import ThreadPoolExecutor

def scan_network(subnet="192.168.1", esp_only=False):
    """Scan the network for devices, optionally filtering for ESP devices"""
    devices = []
    
    def check_host(ip):
        # Try to ping the host
        try:
            result = subprocess.run(
                ["ping", "-c", "1", "-W", "1", ip],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            if result.returncode == 0:
                # Try to get hostname
                try:
                    hostname = socket.gethostbyaddr(ip)[0]
                    # If ESP-only filter is on, check if hostname starts with ESP
                    if esp_only and not (hostname.startswith("ESP") or "ESP" in hostname.upper()):
                        return None
                    return {"name": hostname, "ipAddress": ip}
                except socket.herror:
                    # No hostname found, try to check if it's an ESP device by other means
                    if esp_only:
                        # Try connecting to common ESP ports
                        for port in [80, 8080, 8266]:
                            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            s.settimeout(0.5)
                            try:
                                s.connect((ip, port))
                                s.close()
                                return {"name": f"Unknown-{ip.split('.')[-1]}", "ipAddress": ip}
                            except:
                                pass
                        return None
                    return {"name": f"Unknown-{ip.split('.')[-1]}", "ipAddress": ip}
        except:
            pass
        return None
    
    # Scan the network using ThreadPoolExecutor for faster scanning
    with ThreadPoolExecutor(max_workers=50) as executor:
        ip_list = [f"{subnet}.{i}" for i in range(1, 255)]
        results = executor.map(check_host, ip_list)
        
        for result in results:
            if result:
                devices.append(result)
    
    return devices

def find_esp_devices():
    """Specifically look for ESP devices by checking common patterns"""
    devices = []
    
    # Predefined list of ESP device IPs to check first (from user input)
    esp_ips = [
        "192.168.1.238", "192.168.1.104", "192.168.1.242", "192.168.1.218",
        "192.168.1.83", "192.168.1.137", "192.168.1.131", "192.168.1.118"
    ]
    
    # Known ESP MAC address prefixes to look for
    esp_mac_prefixes = [
        "18:FE:34", "24:0A:C4", "24:6F:28", "24:B2:DE", "2C:3A:E8", "2C:F4:32",
        "30:AE:A4", "3C:61:05", "3C:71:BF", "40:F5:20", "40:91:51", "48:3F:DA",
        "48:55:19", "50:02:91", "54:43:B2", "54:5A:A6", "5C:CF:7F", "60:01:94",
        "68:C6:3A", "84:0D:8E", "84:CC:A8", "84:F3:EB", "8C:AA:B5", "A0:20:A6",
        "A4:7B:9D", "A4:CF:12", "AC:67:B2", "AC:D0:74", "B4:E6:2D", "BC:DD:C2",
        "BC:FF:4D", "C4:4F:33", "C8:2B:96", "CC:50:E3", "D8:A0:1D", "D8:BF:C0",
        "DC:4F:22", "E8:68:E7", "EC:FA:BC", "F0:08:D1", "F4:12:FA"
    ]
    
    # First check the predefined list of ESP IPs
    for ip in esp_ips:
        try:
            # Try to get hostname
            hostname = socket.gethostbyaddr(ip)[0]
            if "ESP" in hostname.upper():
                devices.append({"name": hostname, "ipAddress": ip})
            else:
                # Try to determine if this is an ESP device by checking open ports
                if check_esp_ports(ip):
                    devices.append({"name": f"ESP-Device-{ip.split('.')[-1]}", "ipAddress": ip})
        except:
            # Try to determine if this is an ESP device by checking open ports
            if check_esp_ports(ip):
                devices.append({"name": f"ESP-Device-{ip.split('.')[-1]}", "ipAddress": ip})
    
    # Then scan the whole network for additional ESP devices
    # This would typically use ARP scan to find devices and check MAC addresses
    # For simplicity, we'll just use the predefined list in this example
    
    return devices

def check_esp_ports(ip):
    """Check if the device has common ESP ports open"""
    esp_ports = [80, 81, 8080, 8081, 8266]
    
    for port in esp_ports:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(0.3)
            result = s.connect_ex((ip, port))
            s.close()
            if result == 0:
                return True
        except:
            pass
    
    return False

def toggle_device(ip_address, port=80):
    """Toggle a device's state by sending a request to its IP address"""
    try:
        # For ESP8266/ESP32 devices, we might send an HTTP request to a specific endpoint
        import requests
        response = requests.get(f"http://{ip_address}/toggle", timeout=2)
        return response.text
    except Exception as e:
        return f"Error: {str(e)}"

def control_device(ip_address, command, value, port=80):
    """Send a control command to a device"""
    try:
        # For ESP8266/ESP32 devices with a RESTful API
        import requests
        payload = {command: value}
        response = requests.post(f"http://{ip_address}/control", json=payload, timeout=2)
        return response.text
    except Exception as e:
        return f"Error: {str(e)}"

def set_color(ip_address, r, g, b, port=80):
    """Set RGB color on a device"""
    try:
        import requests
        payload = {"r": r, "g": g, "b": b}
        response = requests.post(f"http://{ip_address}/color", json=payload, timeout=2)
        return response.text
    except Exception as e:
        return f"Error: {str(e)}"

def set_timer(ip_address, timer_type, hours, minutes, enabled=True, port=80):
    """Set a timer on a device"""
    try:
        import requests
        payload = {
            "type": timer_type,  # "on" or "off"
            "hours": hours,
            "minutes": minutes,
            "enabled": enabled
        }
        response = requests.post(f"http://{ip_address}/timer", json=payload, timeout=2)
        return response.text
    except Exception as e:
        return f"Error: {str(e)}"

def main():
    parser = argparse.ArgumentParser(description='Network scanner for SmartLife/ESP devices')
    parser.add_argument('action', choices=['scan', 'scan-esp', 'toggle', 'control', 'color', 'timer'])
    parser.add_argument('--ip', help='IP address for device actions')
    parser.add_argument('--subnet', default='192.168.1', help='Subnet to scan (default: 192.168.1)')
    parser.add_argument('--command', help='Command for control action')
    parser.add_argument('--value', help='Value for control action')
    parser.add_argument('--r', type=int, help='Red color value (0-255)')
    parser.add_argument('--g', type=int, help='Green color value (0-255)')
    parser.add_argument('--b', type=int, help='Blue color value (0-255)')
    parser.add_argument('--timer-type', choices=['on', 'off'], help='Timer type (on/off)')
    parser.add_argument('--hours', type=int, help='Timer hours (0-23)')
    parser.add_argument('--minutes', type=int, help='Timer minutes (0-59)')
    parser.add_argument('--enabled', type=bool, default=True, help='Timer enabled state')
    
    args = parser.parse_args()
    
    if args.action == 'scan':
        devices = scan_network(args.subnet, esp_only=False)
        print(json.dumps(devices))
    
    elif args.action == 'scan-esp':
        devices = find_esp_devices()
        print(json.dumps(devices))
    
    elif args.action == 'toggle':
        if not args.ip:
            print("Error: IP address required for toggle action")
            sys.exit(1)
        response = toggle_device(args.ip)
        print(response)
    
    elif args.action == 'control':
        if not args.ip or not args.command or args.value is None:
            print("Error: IP, command and value required for control action")
            sys.exit(1)
        response = control_device(args.ip, args.command, args.value)
        print(response)
    
    elif args.action == 'color':
        if not args.ip or args.r is None or args.g is None or args.b is None:
            print("Error: IP, r, g, and b values required for color action")
            sys.exit(1)
        response = set_color(args.ip, args.r, args.g, args.b)
        print(response)
    
    elif args.action == 'timer':
        if not args.ip or not args.timer_type or args.hours is None or args.minutes is None:
            print("Error: IP, timer-type, hours, and minutes required for timer action")
            sys.exit(1)
        response = set_timer(args.ip, args.timer_type, args.hours, args.minutes, args.enabled)
        print(response)

if __name__ == "__main__":
    main()    // Function to scan the network for devices
    function scanNetwork() {
        scanning = true;
        
        // In a real implementation, this would call a Python script to scan the network
        // Example: plasmoid.runCommand("python", ["/path/to/network-scanner.py", "scan"]);
        
        // For demo purposes, simulate finding devices after a delay
        Timer.setTimeout(function() {
            // Look for new ESP devices
            const espAddresses = [
                "192.168.1.238", "192.168.1.104", "192.168.1.242", "192.168.1.218",
                "192.168.1.83", "192.168.1.137", "192.168.1.131", "192.168.1.118"
            ];
            
            // Get current device IPs to avoid duplicates
            const existingIps = deviceList.map(d => d.ipAddress);
            
            // List of new ESP devices found during scan
            let newDevicesFound = 0;
            
            // Check each ESP address
            for (let i = 0; i < espAddresses.length; i++) {
                const ip = espAddresses[i];
                
                // Skip if device already exists
                if (existingIps.includes(ip)) continue;
                
                // Create new device with default settings
                const newDevice = {
                    id: Date.now() + i,
                    name: `ESP_${Math.random().toString(16).substring(2, 8).toUpperCase()}`,
                    ipAddress: ip,
                    type: Math.random() > 0.5 ? "light" : "outlet",
                    state: false,
                    brightness: 100,
                    color: "#FFFFFF",
                    timerOn: null,
                    timerOff: null
                };
                
                deviceList.push(newDevice);
                newDevicesFound++;
            }
            
            // Also add a few simulated smart devices
            if (Math.random() > 0.5) {
                const smartplug = {
                    id: Date.now() + 100,
                    name: "Smart Plug",
                    ipAddress: `192.168.1.${Math.floor(Math.random() * 254) + 1}`,
                    type: "outlet",
                    state: false,
                    timerOn: null,
                    timerOff: null
                };
                
                // Only add if IP is unique
                if (!existingIps.includes(smartplug.ipAddress)) {
                    deviceList.push(smartplug);
                    newDevicesFound++;
                }
            }
            
            if (Math.random() > 0.5) {
                const smartswitch = {
                    id: Date.now() + 101,
                    name: "Smart Switch",
                    Project Structure:
org.kde.plasma.smartlifecontroller/
├── metadata.json
├── contents/
│   ├── ui/
│   │   ├── main.qml
│   │   ├── configGeneral.qml
│   │   └── DeviceItem.qml
│   ├── code/
│   │   └── network-scanner.py
│   └── config/
│       └── config.qml


File: metadata.json
{
  "KPlugin": {
    "Authors": [
      {
        "Email": "your.email@example.com",
        "Name": "Your Name"
      }
    ],
    "Category": "System Information",
    "Description": "Control SmartLife/Tuya devices on your network",
    "Icon": "preferences-system-network-sharing",
    "Id": "org.kde.plasma.smartlifecontroller",
    "Name": "SmartLife Controller",
    "Version": "1.0",
    "Website": "https://github.com/yourusername/plasma-smartlife"
  },
  "X-Plasma-API-Minimum-Version": "6.0",
  "KPackageStructure": "Plasma/Applet"
}


File: contents/ui/main.qml
import QtQuick
import QtQuick.Layouts
import QtQuick.Controls
import org.kde.plasma.plasmoid
import org.kde.plasma.core as PlasmaCore
import org.kde.plasma.components as PlasmaComponents
import org.kde.kirigami as Kirigami

PlasmoidItem {
    id: root
    
    // Property to store devices
    property var deviceList: [
        {
            id: 1,
            name: "ESP_554DC9",
            ipAddress: "192.168.1.238",
            type: "light",
            state: false,
            brightness: 80,
            color: "#FFFFFF",
            timerOn: null,
            timerOff: null
        },
        {
            id: 2,
            name: "ESP_554E12",
            ipAddress: "192.168.1.104",
            type: "light",
            state: true,
            brightness: 60,
            color: "#FF5500",
            timerOn: null,
            timerOff: null
        },
        {
            id: 3,
            name: "ESP_554E9C",
            ipAddress: "192.168.1.242",
            type: "light",
            state: false,
            brightness: 100,
            color: "#00FF88",
            timerOn: null,
            timerOff: null
        },
        {
            id: 4,
            name: "ESP_554F53",
            ipAddress: "192.168.1.218",
            type: "light",
            state: true,
            brightness: 70,
            color: "#FFBB00",
            timerOn: null,
            timerOff: null
        },
        {
            id: 5,
            name: "ESP_559186",
            ipAddress: "192.168.1.83",
            type: "outlet",
            state: true,
            timerOn: null,
            timerOff: null
        },
        {
            id: 6,
            name: "ESP_5E7404",
            ipAddress: "192.168.1.137",
            type: "outlet",
            state: false,
            timerOn: null,
            timerOff: null
        },
        {
            id: 7,
            name: "ESP_648294",
            ipAddress: "192.168.1.131",
            type: "light",
            state: true,
            brightness: 90,
            color: "#FFFFFF",
            timerOn: null,
            timerOff: null
        },
        {
            id: 8,
            name: "ESP_650D34",
            ipAddress: "192.168.1.118",
            type: "outlet",
            state: false,
            timerOn: null,
            timerOff: null
        }
    ]
    property bool scanning: false
    property bool showOfflineDevices: Plasmoid.configuration.showOfflineDevices || false
    
    // Set compact representation for panel
    Plasmoid.preferredRepresentation: Plasmoid.compactRepresentation
    
    // Compact representation (icon in panel)
    compactRepresentation: Item {
        id: compactRoot
        
        Layout.minimumWidth: Kirigami.Units.gridUnit * 1.5
        Layout.minimumHeight: Kirigami.Units.gridUnit * 1.5
        
        Kirigami.Icon {
            id: icon
            source: "preferences-system-network-sharing"
            anchors.fill: parent
        }
        
        MouseArea {
            id: mouseArea
            anchors.fill: parent
            onClicked: Plasmoid.expanded = !Plasmoid.expanded
        }
    }
    
    // Full representation (popup)
    fullRepresentation: Item {
        id: fullRoot
        
        Layout.minimumWidth: Kirigami.Units.gridUnit * 20
        Layout.minimumHeight: Kirigami.Units.gridUnit * 24
        Layout.preferredWidth: Kirigami.Units.gridUnit * 24
        Layout.preferredHeight: Kirigami.Units.gridUnit * 28
        
        ColumnLayout {
            anchors.fill: parent
            anchors.margins: Kirigami.Units.smallSpacing
            spacing: Kirigami.Units.smallSpacing
            
            // Title and scan button
            RowLayout {
                Layout.fillWidth: true
                
                Kirigami.Heading {
                    level: 2
                    text: "SmartLife Devices"
                    Layout.fillWidth: true
                }
                
                Button {
                    id: scanButton
                    text: scanning ? "Scanning..." : "Scan Network"
                    icon.name: "view-refresh"
                    enabled: !scanning
                    onClicked: {
                        scanNetwork();
                    }
                }
            }
            
            // Filters and options
            RowLayout {
                Layout.fillWidth: true
                
                CheckBox {
                    id: showOfflineCheck
                    text: "Show Offline"
                    checked: showOfflineDevices
                    onCheckedChanged: {
                        showOfflineDevices = checked;
                        Plasmoid.configuration.showOfflineDevices = checked;
                    }
                }
                
                TextField {
                    id: filterField
                    placeholderText: "Filter devices..."
                    Layout.fillWidth: true
                }
                
                Button {
                    text: "Add Device"
                    icon.name: "list-add"
                    onClicked: {
                        addDeviceDialog.open();
                    }
                }
            }
            
            // Device list
            ScrollView {
                Layout.fillWidth: true
                Layout.fillHeight: true
                
                ListView {
                    id: deviceListView
                    clip: true
                    model: getFilteredDevices()
                    
                    delegate: DeviceItem {
                        width: deviceListView.width
                        deviceName: modelData.name
                        deviceIp: modelData.ipAddress
                        deviceState: modelData.state
                        deviceType: modelData.type
                        deviceBrightness: modelData.brightness || 0
                        
                        onToggleDevice: {
                            toggleDeviceState(modelData.id);
                        }
                        
                        onControlDevice: {
                            openDeviceControl(modelData);
                        }
                        
                        onRemoveDevice: {
                            deleteDevice(modelData.id);
                        }
                    }
                    
                    // Empty state
                    Item {
                        anchors.fill: parent
                        visible: deviceListView.count === 0
                        
                        ColumnLayout {
                            anchors.centerIn: parent
                            spacing: Kirigami.Units.largeSpacing
                            
                            Kirigami.Icon {
                                source: "network-wireless"
                                width: Kirigami.Units.iconSizes.huge
                                height: width
                                Layout.alignment: Qt.AlignHCenter
                            }
                            
                            Kirigami.Heading {
                                level: 3
                                text: "No devices found"
                                Layout.alignment: Qt.AlignHCenter
                            }
                            
                            Label {
                                text: "Scan your network to find SmartLife devices"
                                Layout.alignment: Qt.AlignHCenter
                            }
                            
                            Button {
                                text: "Scan Now"
                                icon.name: "view-refresh"
                                Layout.alignment: Qt.AlignHCenter
                                onClicked: scanNetwork()
                            }
                        }
                    }
                }
            }
            
            // Status bar
            RowLayout {
                Layout.fillWidth: true
                
                Label {
                    text: scanning ? 
                          "Scanning network..." : 
                          (deviceList.length > 0 ? 
                           deviceList.length + " device(s) found" : 
                           "Ready to scan")
                    Layout.fillWidth: true
                }
                
                Label {
                    text: "ESP filter: ON"
                    visible: Plasmoid.configuration.espFilter
                }
            }
        }
        
        // Add device dialog
        Dialog {
            id: addDeviceDialog
            title: "Add SmartLife Device"
            standardButtons: Dialog.Ok | Dialog.Cancel
            
            x: Math.round((parent.width - width) / 2)
            y: Math.round((parent.height - height) / 2)
            width: Kirigami.Units.gridUnit * 20
            modal: true
            
            onAccepted: {
                if (deviceNameField.text && deviceIpField.text) {
                    addDevice({
                        id: Date.now(),
                        name: deviceNameField.text,
                        ipAddress: deviceIpField.text,
                        type: deviceTypeCombo.currentText.toLowerCase(),
                        state: false,
                        brightness: 100,
                        color: "#FFFFFF"
                    });
                    deviceNameField.text = "";
                    deviceIpField.text = "";
                }
            }
            
            onClosed: {
                deviceNameField.text = "";
                deviceIpField.text = "";
            }
            
            contentItem: ColumnLayout {
                spacing: Kirigami.Units.smallSpacing
                
                Label {
                    text: "Device Name:"
                }
                
                TextField {
                    id: deviceNameField
                    placeholderText: "Living Room Light"
                    Layout.fillWidth: true
                }
                
                Label {
                    text: "IP Address:"
                }
                
                TextField {
                    id: deviceIpField
                    placeholderText: "192.168.1.100"
                    Layout.fillWidth: true
                }
                
                Label {
                    text: "Device Type:"
                }
                
                ComboBox {
                    id: deviceTypeCombo
                    model: ["Light", "Switch", "Outlet", "Thermostat", "Other"]
                    Layout.fillWidth: true
                }
                
                Button {
                    text: "Scan for ESP Devices"
                    icon.name: "network-wireless"
                    Layout.fillWidth: true
                    onClicked: {
                        scanForEspDevices();
                    }
                }
            }
        }
        
            // Device control dialog
        Dialog {
            id: deviceControlDialog
            title: "Device Control"
            standardButtons: Dialog.Close
            
            property var currentDevice: null
            
            x: Math.round((parent.width - width) / 2)
            y: Math.round((parent.height - height) / 2)
            width: Kirigami.Units.gridUnit * 24
            height: Kirigami.Units.gridUnit * 28
            modal: true
            
            contentItem: ColumnLayout {
                spacing: Kirigami.Units.smallSpacing
                
                // Device name and IP
                RowLayout {
                    Layout.fillWidth: true
                    
                    Kirigami.Heading {
                        level: 3
                        text: deviceControlDialog.currentDevice ? 
                              deviceControlDialog.currentDevice.name : ""
                        Layout.fillWidth: true
                    }
                    
                    Label {
                        text: deviceControlDialog.currentDevice ? 
                              deviceControlDialog.currentDevice.ipAddress : ""
                        opacity: 0.7
                    }
                }
                
                // Tab bar for different control options
                TabBar {
                    id: controlTabs
                    Layout.fillWidth: true
                    
                    TabButton {
                        text: "Basic"
                        icon.name: "configure"
                    }
                    
                    TabButton {
                        text: "Colors"
                        icon.name: "preferences-desktop-color"
                        visible: deviceControlDialog.currentDevice && 
                                 deviceControlDialog.currentDevice.type === "light"
                    }
                    
                    TabButton {
                        text: "Timer"
                        icon.name: "chronometer"
                    }
                }
                
                // Stacked layout for tab content
                StackLayout {
                    currentIndex: controlTabs.currentIndex
                    Layout.fillWidth: true
                    Layout.fillHeight: true
                    
                    // Basic controls
                    ColumnLayout {
                        spacing: Kirigami.Units.largeSpacing
                        
                        GroupBox {
                            title: "Power"
                            Layout.fillWidth: true
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                Switch {
                                    id: deviceSwitch
                                    text: checked ? "ON" : "OFF"
                                    font.pointSize: Kirigami.Theme.defaultFont.pointSize * 1.5
                                    checked: deviceControlDialog.currentDevice ? 
                                             deviceControlDialog.currentDevice.state : false
                                    onCheckedChanged: {
                                        if (deviceControlDialog.currentDevice) {
                                            updateDeviceProperty(
                                                deviceControlDialog.currentDevice.id, 
                                                "state", 
                                                checked
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        
                        GroupBox {
                            title: "Brightness"
                            Layout.fillWidth: true
                            visible: deviceControlDialog.currentDevice && 
                                     deviceControlDialog.currentDevice.type === "light"
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                RowLayout {
                                    Layout.fillWidth: true
                                    
                                    Kirigami.Icon {
                                        source: "low-brightness"
                                        width: Kirigami.Units.iconSizes.small
                                        height: width
                                    }
                                    
                                    Slider {
                                        id: brightnessSlider
                                        from: 1
                                        to: 100
                                        value: deviceControlDialog.currentDevice && 
                                               deviceControlDialog.currentDevice.type === "light" ? 
                                               deviceControlDialog.currentDevice.brightness : 100
                                        Layout.fillWidth: true
                                        onValueChanged: {
                                            if (deviceControlDialog.currentDevice && 
                                                deviceControlDialog.currentDevice.type === "light") {
                                                updateDeviceProperty(
                                                    deviceControlDialog.currentDevice.id, 
                                                    "brightness", 
                                                    Math.round(value)
                                                );
                                            }
                                        }
                                    }
                                    
                                    Kirigami.Icon {
                                        source: "high-brightness"
                                        width: Kirigami.Units.iconSizes.small
                                        height: width
                                    }
                                    
                                    Label {
                                        text: Math.round(brightnessSlider.value) + "%"
                                        Layout.preferredWidth: Kirigami.Units.gridUnit * 3
                                        horizontalAlignment: Text.AlignRight
                                    }
                                }
                            }
                        }
                        
                        GroupBox {
                            title: "Light Temperature"
                            Layout.fillWidth: true
                            visible: deviceControlDialog.currentDevice && 
                                     deviceControlDialog.currentDevice.type === "light"
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                RowLayout {
                                    Layout.fillWidth: true
                                    
                                    Kirigami.Icon {
                                        source: "weather-clear-night"
                                        width: Kirigami.Units.iconSizes.small
                                        height: width
                                    }
                                    
                                    Slider {
                                        id: temperatureSlider
                                        from: 1
                                        to: 100
                                        value: 50
                                        Layout.fillWidth: true
                                    }
                                    
                                    Kirigami.Icon {
                                        source: "weather-clear"
                                        width: Kirigami.Units.iconSizes.small
                                        height: width
                                    }
                                    
                                    Label {
                                        text: temperatureSlider.value < 33 ? "Cool" : 
                                             (temperatureSlider.value < 66 ? "Neutral" : "Warm")
                                        Layout.preferredWidth: Kirigami.Units.gridUnit * 3
                                        horizontalAlignment: Text.AlignRight
                                    }
                                }
                            }
                        }
                        
                        Item {
                            Layout.fillHeight: true
                        }
                    }
                    
                    // Color controls
                    ColumnLayout {
                        spacing: Kirigami.Units.largeSpacing
                        visible: deviceControlDialog.currentDevice && 
                                 deviceControlDialog.currentDevice.type === "light"
                        
                        GroupBox {
                            title: "RGB Color"
                            Layout.fillWidth: true
                            
                            GridLayout {
                                columns: 3
                                rowSpacing: Kirigami.Units.smallSpacing
                                columnSpacing: Kirigami.Units.smallSpacing
                                anchors.fill: parent
                                
                                Label { text: "Red:" }
                                Slider {
                                    id: redSlider
                                    from: 0
                                    to: 255
                                    value: 255
                                    Layout.fillWidth: true
                                    onValueChanged: updateColorFromRGB()
                                }
                                SpinBox {
                                    from: 0
                                    to: 255
                                    value: redSlider.value
                                    onValueChanged: {
                                        redSlider.value = value;
                                        updateColorFromRGB();
                                    }
                                }
                                
                                Label { text: "Green:" }
                                Slider {
                                    id: greenSlider
                                    from: 0
                                    to: 255
                                    value: 255
                                    Layout.fillWidth: true
                                    onValueChanged: updateColorFromRGB()
                                }
                                SpinBox {
                                    from: 0
                                    to: 255
                                    value: greenSlider.value
                                    onValueChanged: {
                                        greenSlider.value = value;
                                        updateColorFromRGB();
                                    }
                                }
                                
                                Label { text: "Blue:" }
                                Slider {
                                    id: blueSlider
                                    from: 0
                                    to: 255
                                    value: 255
                                    Layout.fillWidth: true
                                    onValueChanged: updateColorFromRGB()
                                }
                                SpinBox {
                                    from: 0
                                    to: 255
                                    value: blueSlider.value
                                    onValueChanged: {
                                        blueSlider.value = value;
                                        updateColorFromRGB();
                                    }
                                }
                            }
                        }
                        
                        GroupBox {
                            title: "Color Presets"
                            Layout.fillWidth: true
                            
                            GridLayout {
                                columns: 4
                                anchors.fill: parent
                                rowSpacing: Kirigami.Units.smallSpacing
                                columnSpacing: Kirigami.Units.smallSpacing
                                
                                Repeater {
                                    model: [
                                        "#FFFFFF", "#FFF4E0", "#FFD700", "#FF6347", 
                                        "#87CEFA", "#90EE90", "#FF00FF", "#FF5500",
                                        "#00FFFF", "#00FF88", "#AAAAFF", "#FF0000"
                                    ]
                                    
                                    Rectangle {
                                        width: Kirigami.Units.gridUnit * 2.5
                                        height: Kirigami.Units.gridUnit * 2.5
                                        color: modelData
                                        border.width: deviceControlDialog.currentDevice && 
                                                     deviceControlDialog.currentDevice.color === modelData ? 3 : 1
                                        border.color: deviceControlDialog.currentDevice && 
                                                     deviceControlDialog.currentDevice.color === modelData ? 
                                                     Kirigami.Theme.highlightColor : Kirigami.Theme.disabledTextColor
                                        radius: 4
                                        
                                        Layout.fillWidth: true
                                        Layout.fillHeight: true
                                        
                                        MouseArea {
                                            anchors.fill: parent
                                            onClicked: {
                                                if (deviceControlDialog.currentDevice) {
                                                    updateDeviceProperty(
                                                        deviceControlDialog.currentDevice.id, 
                                                        "color", 
                                                        modelData
                                                    );
                                                    setRGBSlidersFromColor(modelData);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        Rectangle {
                            id: colorPreview
                            Layout.fillWidth: true
                            Layout.preferredHeight: Kirigami.Units.gridUnit * 3
                            color: deviceControlDialog.currentDevice ? 
                                   deviceControlDialog.currentDevice.color : "#FFFFFF"
                            border.width: 1
                            border.color: Kirigami.Theme.disabledTextColor
                            radius: 4
                            
                            Label {
                                anchors.centerIn: parent
                                text: deviceControlDialog.currentDevice ? 
                                      deviceControlDialog.currentDevice.color : "#FFFFFF"
                                color: isDarkColor(parent.color) ? "white" : "black"
                                font.bold: true
                            }
                        }
                        
                        Item {
                            Layout.fillHeight: true
                        }
                    }
                    
                    // Timer controls
                    ColumnLayout {
                        spacing: Kirigami.Units.largeSpacing
                        
                        GroupBox {
                            title: "Turn ON Timer"
                            Layout.fillWidth: true
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                RowLayout {
                                    Layout.fillWidth: true
                                    
                                    CheckBox {
                                        id: timerOnEnabled
                                        text: "Enable"
                                        checked: deviceControlDialog.currentDevice && 
                                                deviceControlDialog.currentDevice.timerOn !== null
                                    }
                                    
                                    Label {
                                        text: "Time:"
                                        visible: timerOnEnabled.checked
                                    }
                                    
                                    SpinBox {
                                        id: timerOnHours
                                        from: 0
                                        to: 23
                                        value: 18
                                        visible: timerOnEnabled.checked
                                    }
                                    
                                    Label {
                                        text: ":"
                                        visible: timerOnEnabled.checked
                                    }
                                    
                                    SpinBox {
                                        id: timerOnMinutes
                                        from: 0
                                        to: 59
                                        value: 0
                                        visible: timerOnEnabled.checked
                                    }
                                    
                                    Button {
                                        text: "Apply"
                                        icon.name: "dialog-ok-apply"
                                        visible: timerOnEnabled.checked
                                        onClicked: {
                                            if (deviceControlDialog.currentDevice) {
                                                let timerValue = null;
                                                if (timerOnEnabled.checked) {
                                                    timerValue = {
                                                        hours: timerOnHours.value,
                                                        minutes: timerOnMinutes.value
                                                    };
                                                }
                                                updateDeviceProperty(
                                                    deviceControlDialog.currentDevice.id,
                                                    "timerOn",
                                                    timerValue
                                                );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        GroupBox {
                            title: "Turn OFF Timer"
                            Layout.fillWidth: true
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                RowLayout {
                                    Layout.fillWidth: true
                                    
                                    CheckBox {
                                        id: timerOffEnabled
                                        text: "Enable"
                                        checked: deviceControlDialog.currentDevice && 
                                                deviceControlDialog.currentDevice.timerOff !== null
                                    }
                                    
                                    Label {
                                        text: "Time:"
                                        visible: timerOffEnabled.checked
                                    }
                                    
                                    SpinBox {
                                        id: timerOffHours
                                        from: 0
                                        to: 23
                                        value: 23
                                        visible: timerOffEnabled.checked
                                    }
                                    
                                    Label {
                                        text: ":"
                                        visible: timerOffEnabled.checked
                                    }
                                    
                                    SpinBox {
                                        id: timerOffMinutes
                                        from: 0
                                        to: 59
                                        value: 0
                                        visible: timerOffEnabled.checked
                                    }
                                    
                                    Button {
                                        text: "Apply"
                                        icon.name: "dialog-ok-apply"
                                        visible: timerOffEnabled.checked
                                        onClicked: {
                                            if (deviceControlDialog.currentDevice) {
                                                let timerValue = null;
                                                if (timerOffEnabled.checked) {
                                                    timerValue = {
                                                        hours: timerOffHours.value,
                                                        minutes: timerOffMinutes.value
                                                    };
                                                }
                                                updateDeviceProperty(
                                                    deviceControlDialog.currentDevice.id,
                                                    "timerOff",
                                                    timerValue
                                                );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        GroupBox {
                            title: "Timer Status"
                            Layout.fillWidth: true
                            
                            ColumnLayout {
                                anchors.fill: parent
                                
                                Label {
                                    text: getTimerStatusText()
                                    wrapMode: Text.Wrap
                                    Layout.fillWidth: true
                                }
                            }
                        }
                        
                        Item {
                            Layout.fillHeight: true
                        }
                    }
                }
            }
            
            // Set RGB sliders when dialog opens
            onOpened: {
                if (currentDevice && currentDevice.type === "light") {
                    setRGBSlidersFromColor(currentDevice.color);
                }
                
                // Set timer values
                if (currentDevice) {
                    if (currentDevice.timerOn) {
                        timerOnHours.value = currentDevice.timerOn.hours;
                        timerOnMinutes.value = currentDevice.timerOn.minutes;
                    } else {
                        timerOnHours.value = 18;
                        timerOnMinutes.value = 0;
                    }
                    
                    if (currentDevice.timerOff) {
                        timerOffHours.value = currentDevice.timerOff.hours;
                        timerOffMinutes.value = currentDevice.timerOff.minutes;
                    } else {
                        timerOffHours.value = 23;
                        timerOffMinutes.value = 0;
                    }
                }
            }
            
            function updateColorFromRGB() {
                if (!deviceControlDialog.currentDevice) return;
                
                // Convert RGB to hex
                const r = Math.round(redSlider.value).toString(16).padStart(2, '0');
                const g = Math.round(greenSlider.value).toString(16).padStart(2, '0');
                const b = Math.round(blueSlider.value).toString(16).padStart(2, '0');
                const colorHex = "#" + r + g + b;
                
                updateDeviceProperty(
                    deviceControlDialog.currentDevice.id,
                    "color",
                    colorHex.toUpperCase()
                );
            }
            
            function setRGBSlidersFromColor(colorHex) {
                // Parse hex color to RGB
                const r = parseInt(colorHex.substring(1, 3), 16);
                const g = parseInt(colorHex.substring(3, 5), 16);
                const b = parseInt(colorHex.substring(5, 7), 16);
                
                // Update sliders
                redSlider.value = r;
                greenSlider.value = g;
                blueSlider.value = b;
            }
            
            function isDarkColor(colorHex) {
                // Convert hex to RGB
                const r = parseInt(colorHex.substring(1, 3), 16);
                const g = parseInt(colorHex.substring(3, 5), 16);
                const b = parseInt(colorHex.substring(5, 7), 16);
                
                // Calculate perceived brightness
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                
                // Return true if dark
                return brightness < 128;
            }
            
            function getTimerStatusText() {
                if (!deviceControlDialog.currentDevice) return "No device selected";
                
                let text = "";
                if (deviceControlDialog.currentDevice.timerOn) {
                    const h = deviceControlDialog.currentDevice.timerOn.hours;
                    const m = deviceControlDialog.currentDevice.timerOn.minutes;
                    text += `Will turn ON at ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}\n`;
                }
                
                if (deviceControlDialog.currentDevice.timerOff) {
                    const h = deviceControlDialog.currentDevice.timerOff.hours;
                    const m = deviceControlDialog.currentDevice.timerOff.minutes;
                    text += `Will turn OFF at ${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
                }
                
                return text || "No timers set";
            }
        }
    }
    
    Component.onCompleted: {
        // Load saved devices
        loadSavedDevices();
    }
    
    // Function to filter devices based on search text and showOffline setting
    function getFilteredDevices() {
        if (!deviceList) return [];
        
        let filtered = deviceList;
        
        // Filter by search text
        if (filterField && filterField.text) {
            const searchText = filterField.text.toLowerCase();
            filtered = filtered.filter(device => 
                device.name.toLowerCase().includes(searchText) || 
                device.ipAddress.toLowerCase().includes(searchText)
            );
        }
        
        // Filter offline devices if needed
        if (!showOfflineDevices) {
            filtered = filtered.filter(device => device.state);
        }
        
        return filtered;
    }
    
    // Function to load saved devices
    function loadSavedDevices() {
        const savedDevices = Plasmoid.configuration.savedDevices || "[]";
        try {
            deviceList = JSON.parse(savedDevices);
            deviceListView.model = getFilteredDevices();
        } catch (e) {
            console.error("Error loading saved devices:", e);
            deviceList = [];
        }
    }
    
    // Function to save devices
    function saveDevices() {
        Plasmoid.configuration.savedDevices = JSON.stringify(deviceList);
    }
    
    // Function to add a device
    function addDevice(device) {
        deviceList.push(device);
        saveDevices();
        deviceListView.model = getFilteredDevices();
    }
    
    // Function to delete a device
    function deleteDevice(id) {
        deviceList = deviceList.filter(d => d.id !== id);
        saveDevices();
        deviceListView.model = getFilteredDevices();
    }
    
    // Function to toggle device state
    function toggleDeviceState(id) {
        const index = deviceList.findIndex(d => d.id === id);
        if (index >= 0) {
            deviceList[index].state = !deviceList[index].state;
            saveDevices();
            deviceListView.model = getFilteredDevices();
            
            // In a real implementation, this would send a command to the actual device
            console.log("Toggling device:", deviceList[index].name, "to", deviceList[index].state);
            
            // This would call the Python script to control the device
            // Example: plasmoid.runCommand("python", ["/path/to/network-scanner.py", "toggle", deviceList[index].ipAddress]);
        }
    }
    
    // Function to update a device property
    function updateDeviceProperty(id, property, value) {
        const index = deviceList.findIndex(d => d.id === id);
        if (index >= 0) {
            deviceList[index][property] = value;
            saveDevices();
            deviceListView.model = getFilteredDevices();
            
            // In a real implementation, this would send the updated property to the device
            console.log("Updating device:", deviceList[index].name, property, "to", value);
        }
    }
    
    // Function to open device control dialog
    function openDeviceControl(device) {
        deviceControlDialog.currentDevice = device;
        deviceControlDialog.open();
    }
    
    // Function to scan the network for devices
    function scanNetwork() {
        scanning = true;
        
        // In a real implementation, this would call a Python script to scan the network
        // Example: plasmoid.runCommand("python", ["/path/to/network-scanner.py", "scan"]);
        
        // For demo purposes, simulate finding devices after a delay
        Timer.setTimeout(function() {
            // Look for new ESP devices
            const espAddresses = [
                "192.168.1.238", "192.168.1.104", "192.168.1.242", "192.168.1.218",
                "192.168.1.83", "192.168.1.137", "192.168.1.131", "192.168.1.118"
            ];
            
            // Get current device IPs to avoid duplicates
            const existingIps = deviceList.map(d => d.ipAddress);
            
            // List of new ESP devices found during scan
            let newDevicesFound = 0;
            
            // Check each ESP address
            for (let i = 0; i < espAddresses.length; i++) {
                const ip = espAddresses[i];
                
                // Skip if device already exists
                if (existingIps.includes(ip)) continue;
                
                // Create new device with default settings
                const newDevice = {
                    id: Date.now() + i,
                    name: `ESP_${Math.random().toString(16).substring(2, 8).toUpperCase()}`,
                    ipAddress: ip,
                    type: Math.random() > 0.5 ? "light" : "outlet",
                    state: false,
                    brightness: 100,
                    color: "#FFFFFF",
                    timerOn: null,
                    timerOff: null
                };
                
                deviceList.push(newDevice);
                newDevicesFound++;
            }
            
            // Also add a few simulated smart devices
            if (Math.random() > 0.5) {
                const smartplug = {
                    id: Date.now() + 100,
                    name: "Smart Plug",
                    ipAddress: `192.168.1.${Math.floor(Math.random() * 254) + 1}`,
                    type: "outlet",
                    state: false,
                    timerOn: null,
                    timerOff: null
                };
                
                // Only add if IP is unique
                if (!existingIps.includes(smartplug.ipAddress)) {
                    deviceList.push(smartplug);
                    newDevicesFound++;
                }
            }
            
            if (Math.random() > 0.5) {
                const smartswitch = {
                    id: Date.now() + 101,
                    name: "Smart Switch",
                    ipAddress: `192.168.1.${Math.floor(Math.random() * 254) + 1}`,
                    type: "switch",
                    state: false,
                    timerOn: null,
                    timerOff: null
                };
                
                // Only add if IP is unique
                if (!existingIps.includes(smartswitch.ipAddress)) {
                    deviceList.push(smartswitch);
                    newDevicesFound++;
                }
            }
            
            saveDevices();
            deviceListView.model = getFilteredDevices();
            
            // Show notification
            if (newDevicesFound > 0) {
                showNotification(`Found ${newDevicesFound} new device(s)`, "dialog-information");
            } else {
                showNotification("No new devices found", "dialog-information");
            }
            
            scanning = false;
        }, 2000);
    }
    
    // Function to scan specifically for ESP devices
    function scanForEspDevices() {
        // In a real implementation, this would execute a Python script to find ESP devices
        // Example: plasmoid.runCommand("python", ["/path/to/network-scanner.py", "scan-esp"]);
        
        // For demo purposes, simulate finding ESP devices after a delay
        Timer.setTimeout(function() {
            // Simulate finding ESP devices based on provided list
            const espDevices = [
                { name: "ESP_554DC9", ipAddress: "192.168.1.238" },
                { name: "ESP_554E12", ipAddress: "192.168.1.104" },
                { name: "ESP_554E9C", ipAddress: "192.168.1.242" },
                { name: "ESP_554F53", ipAddress: "192.168.1.218" },
                { name: "ESP_559186", ipAddress: "192.168.1.83" },
                { name: "ESP_5E7404", ipAddress: "192.168.1.137" },
                { name: "ESP_648294", ipAddress: "192.168.1.131" },
                { name: "ESP_650D34", ipAddress: "192.168.1.118" }
            ];
            
            // Select a random ESP device from the list
            if (espDevices.length > 0) {
                const randomIndex = Math.floor(Math.random() * espDevices.length);
                deviceNameField.text = espDevices[randomIndex].name;
                deviceIpField.text = espDevices[randomIndex].ipAddress;
            }
        }, 1500);
    }
    
    // Function to show a notification
    function showNotification(message, icon) {
        // In a real implementation, this would show a plasma notification
        console.log(`Notification: ${message}`);
    }
}


File: contents/ui/DeviceItem.qml
import QtQuick
import QtQuick.Layouts
import QtQuick.Controls
import org.kde.kirigami as Kirigami

Item {
    id: root
    
    property string deviceName: ""
    property string deviceIp: ""
    property bool deviceState: false
    property string deviceType: "light"
    property int deviceBrightness: 0
    property string deviceColor: "#FFFFFF"
    property var deviceTimerOn: null
    property var deviceTimerOff: null
    
    signal toggleDevice()
    signal controlDevice()
    signal removeDevice()
    
    height: Kirigami.Units.gridUnit * 3.5
    
    Rectangle {
        anchors.fill: parent
        anchors.margins: 2
        radius: 4
        color: deviceState ? Kirigami.Theme.backgroundColor : Kirigami.Theme.disabledTextColor
        opacity: deviceState ? 1.0 : 0.7
        
        border.width: 1
        border.color: Kirigami.Theme.disabledTextColor
        
        // Color indicator for lights
        Rectangle {
            width: 4
            anchors {
                top: parent.top
                bottom: parent.bottom
                left: parent.left
            }
            visible: deviceType === "light" && deviceState
            color: deviceColor || "#FFFFFF"
            radius: 4
        }
        
        RowLayout {
            anchors.fill: parent
            anchors.margins: Kirigami.Units.smallSpacing
            spacing: Kirigami.Units.smallSpacing
            
            // Device icon
            Kirigami.Icon {
                source: {
                    switch(deviceType) {
                        case "light": return "light-bulb";
                        case "switch": return "dialog-ok-apply";
                        case "outlet": return "power-plug";
                        case "thermostat": return "temperature-normal";
                        default: return "network-connect";
                    }
                }
                width: Kirigami.Units.iconSizes.medium
                height: width
                color: deviceState ? 
                       (deviceType === "light" ? "gold" : Kirigami.Theme.positiveTextColor) : 
                       Kirigami.Theme.disabledTextColor
            }
            
            // Device info
            ColumnLayout {
                Layout.fillWidth: true
                spacing: 2
                
                Label {
                    text: deviceName
                    font.bold: true
                    elide: Text.ElideRight
                    Layout.fillWidth: true
                }
                
                Label {
                    text: deviceIp
                    font.pointSize: Kirigami.Theme.defaultFont.pointSize * 0.8
                    opacity: 0.7
                    elide: Text.ElideRight
                    Layout.fillWidth: true
                }
                
                RowLayout {
                    spacing: Kirigami.Units.smallSpacing
                    
                    Label {
                        text: deviceType === "light" && deviceState ? 
                            "Brightness: " + deviceBrightness + "%" : 
                            (deviceState ? "ON" : "OFF")
                        font.pointSize: Kirigami.Theme.defaultFont.pointSize * 0.8
                        opacity: 0.9
                    }
                    
                    // Timer indicators
                    Row {
                        spacing: 2
                        visible: deviceTimerOn !== null || deviceTimerOff !== null
                        
                        Kirigami.Icon {
                            source: "chronometer"
                            width: Kirigami.Units.iconSizes.small
                            height: width
                            opacity: 0.7
                            visible: deviceTimerOn !== null
                            
                            ToolTip.visible: timerOnMA.containsMouse
                            ToolTip.text: deviceTimerOn ? 
                                       `ON at ${deviceTimerOn.hours.toString().padStart(2, '0')}:${deviceTimerOn.minutes.toString().padStart(2, '0')}` : 
                                       ""
                            
                            MouseArea {
                                id: timerOnMA
                                anchors.fill: parent
                                hoverEnabled: true
                            }
                        }
                        
                        Kirigami.Icon {
                            source: "chronometer-pause"
                            width: Kirigami.Units.iconSizes.small
                            height: width
                            opacity: 0.7
                            visible: deviceTimerOff !== null
                            
                            ToolTip.visible: timerOffMA.containsMouse
                            ToolTip.text: deviceTimerOff ? 
                                       `OFF at ${deviceTimerOff.hours.toString().padStart(2, '0')}:${deviceTimerOff.minutes.toString().padStart(2, '0')}` : 
                                       ""
                            
                            MouseArea {
                                id: timerOffMA
                                anchors.fill: parent
                                hoverEnabled: true
                            }
                        }
                    }
                }
            }
            
            // Controls
            Row {
                spacing: Kirigami.Units.smallSpacing
                
                Button {
                    icon.name: "configure"
                    display: Button.IconOnly
                    ToolTip.text: "Control Device"
                    ToolTip.visible: hovered
                    onClicked: controlDevice()
                }
                
                Button {
                    icon.name: deviceState ? "dialog-cancel" : "dialog-ok-apply"
                    display: Button.IconOnly
                    ToolTip.text: deviceState ? "Turn Off" : "Turn On"
                    ToolTip.visible: hovered
                    onClicked: toggleDevice()
                }
                
                Button {
                    icon.name: "edit-delete"
                    display: Button.IconOnly
                    ToolTip.text: "Remove Device"
                    ToolTip.visible: hovered
                    onClicked: removeDevice()
                }
            }
        }
    }
    
    MouseArea {
        anchors.fill: parent
        onClicked: controlDevice()
        z: -1 // Behind the buttons
    }
}


File: contents/ui/configGeneral.qml
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import org.kde.kirigami as Kirigami
import org.kde.plasma.core as PlasmaCore

Item {
    id: root
    
    property alias cfg_showOfflineDevices: showOfflineCheck.checked
    property alias cfg_espFilter: espFilterCheck.checked
    property alias cfg_savedDevices: savedDevicesField.text
    
    ColumnLayout {
        anchors.fill: parent
        
        CheckBox {
            id: showOfflineCheck
            text: "Show offline devices"
        }
        
        CheckBox {
            id: espFilterCheck
            text: "Filter for ESP devices when scanning"
            checked: true
        }
        
        Label {
            text: "Advanced Settings"
            font.bold: true
            Layout.topMargin: Kirigami.Units.largeSpacing
        }
        
        Label {
            text: "Devices data (JSON):"
            Layout.topMargin: Kirigami.Units.smallSpacing
        }
        
        TextArea {
            id: savedDevicesField
            Layout.fillWidth: true
            Layout.fillHeight: true
            wrapMode: TextEdit.Wrap
            textFormat: TextEdit.PlainText
            placeholderText: "[]"
        }
        
        Button {
            text: "Reset Device List"
            icon.name: "edit-clear-all"
            onClicked: {
                savedDevicesField.text = "[]";
            }
        }
    }
}


File: contents/code/network-scanner.py
#!/usr/bin/env python3

import sys
import subprocess
import socket
import json
import time
import argparse
from concurrent.futures import ThreadPoolExecutor

def scan_network(subnet="192.168.1", esp_only=False):
    """Scan the network for devices, optionally filtering for ESP devices"""
    devices = []
    
    def check_host(ip):
        # Try to ping the host
        try:
            result = subprocess.run(
                ["ping", "-c", "1", "-W", "1", ip],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            if result.returncode == 0:
                # Try to get hostname
                try:
                    hostname = socket.gethostbyaddr(ip)[0]
                    # If ESP-only filter is on, check if hostname starts with ESP
                    if esp_only and not (hostname.startswith("ESP") or "ESP" in hostname.upper()):
                        return None
                    return {"name": hostname, "ipAddress": ip}
                except socket.herror:
                    # No hostname found, try to check if it's an ESP device by other means
                    if esp_only:
                        # Try connecting to common ESP ports
                        for port in [80, 8080, 8266]:
                            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            s.settimeout(0.5)
                            try:
                                s.connect((ip, port))
                                s.close()
                                return {"name": f"Unknown-{ip.split('.')[-1]}", "ipAddress": ip}
                            except:
                                pass
                        return None
                    return {"name": f"Unknown-{ip.split('.')[-1]}", "ipAddress": ip}
        except:
            pass
        return None
    
    # Scan the network using ThreadPoolExecutor for faster scanning
    with ThreadPoolExecutor(max_workers=50) as executor:
        ip_list = [f"{subnet}.{i}" for i in range(1, 255)]
        results = executor.map(check_host, ip_list)
        
        for result in results:
            if result:
                devices.append(result)
    
    return devices

def toggle_device(ip_address, port=80):
    """Toggle a device's state by sending a request to its IP address"""
    try:
        # This is a simplified example. In a real implementation,
        # you would need to use the appropriate protocol for the device.
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((ip_address, port))
        s.send(b'TOGGLE\r\n')
        response = s.recv(1024)
        s.close()
        return response.decode('utf-8').strip()
    except Exception as e:
        return f"Error: {str(e)}"

def control_device(ip_address, command, value, port=80):
    """Send a control command to a device"""
    try:
        # This is a simplified example. In a real implementation,
        # you would need to use the appropriate protocol for the device.
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        s.connect((ip_address, port))
        s.send(f"{command}:{value}\r\n".encode('utf-8'))
        response = s.recv(1024)
        s.close()
        return response.decode('utf-8').strip()
    except Exception as e:
        return f"Error: {str(e)}"

def main():
    parser = argparse.ArgumentParser(description='Network scanner for SmartLife devices')
    parser.add_argument('action', choices=['scan', 'scan-esp', 'toggle', 'control'])
    parser.add_argument('--ip', help='IP address for toggle/control actions')
    parser.add_argument('--subnet', default='192.168.1', help='Subnet to scan (default: 192.168.1)')
    parser.add_argument('--command', help='Command for control action')
    parser.add_argument('--value', help='Value for control action')
    args = parser.parse_args()
    
    if args.action == 'scan':
        devices = scan_network(args.subnet, esp_only=False)
        print(json.dumps(devices))
    
    elif args.action == 'scan-esp':
        devices = scan_network(args.subnet, esp_only=True)
        print(json.dumps(devices))
    
    elif args.action == 'toggle':
        if not args.ip:
            print("Error: IP address required for toggle action")
            sys.exit(1)
        response = toggle_device(args.ip)
        print(response)
    
    elif args.action == 'control':
        if not args.ip or not args.command or args.value is None:
            print("Error: IP, command and value required for control action
